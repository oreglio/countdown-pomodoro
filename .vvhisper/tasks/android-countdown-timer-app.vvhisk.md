# PRP: Android Countdown Timer App with Circular Progress

## Executive Summary
Create a native Android app using Kotlin and Jetpack Compose that allows users to set a target hour/minute, displays a countdown timer (hours:minutes:seconds), shows a circular progress indicator representing time remaining, and includes pause/stop/reset controls.

## Current State Analysis

### Project Structure
- **Project Type**: New Android project (empty folder)
- **Key Directories**: None yet - project needs to be created from scratch
- **Configuration Files**: None - will be generated by Android Studio

### Target Technology Stack
- **Language**: Kotlin
- **UI Framework**: Jetpack Compose (Material 3)
- **Min SDK**: API 21 (Android 5.0 Lollipop)
- **Target SDK**: API 34 (Android 14)
- **Kotlin Version**: 2.0.0+
- **Compose BOM**: 2024.02.00+

### Dependencies Required
```kotlin
// Compose BOM
implementation(platform("androidx.compose:compose-bom:2024.02.00"))

// Core Compose
implementation("androidx.compose.ui:ui")
implementation("androidx.compose.ui:ui-graphics")
implementation("androidx.compose.ui:ui-tooling-preview")
implementation("androidx.compose.material3:material3")

// Activity Compose
implementation("androidx.activity:activity-compose:1.8.2")

// Lifecycle & ViewModel
implementation("androidx.lifecycle:lifecycle-runtime-compose:2.7.0")
implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0")

// Coroutines
implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
```

## Research Findings

### Official Documentation
Based on [Android Developers - Jetpack Compose Setup](https://developer.android.com/develop/ui/compose/setup):
- Jetpack Compose requires minSdkVersion 21+
- Kotlin is the only supported language
- With Kotlin 2.0+, use the Compose Compiler Gradle plugin

Based on [Android Developers - Time Pickers](https://developer.android.com/develop/ui/compose/components/time-pickers):
- Use `TimePicker` or `TimeInput` composables for time selection
- `rememberTimePickerState()` manages picker state
- Parameters: `initialHour`, `initialMinute`, `is24Hour`

Based on [Android Developers - Progress Indicators](https://developer.android.com/develop/ui/compose/components/progress):
- `CircularProgressIndicator` with `progress` parameter (0.0f to 1.0f)
- For custom progress, use Canvas with `drawArc`

### Community Resources
Based on [Droidcon - Animated Circular Progress Indicator](https://www.droidcon.com/2023/09/01/animated-circular-progress-indicator-using-jetpack-compose/):
- Use Canvas `drawArc` for custom circular progress
- `startAngle = 270f` for 12 o'clock position
- `sweepAngle = progress * 360` for progress arc
- `useCenter = false` with `Stroke` style for ring appearance

Based on [Medium - Circular Progress Bar Guide](https://medium.com/@esthcarelle/circular-progress-bar-with-jetpack-compose-a-step-by-step-guide-851e75fd06e2):
- Calculate progress as `remainingTime / totalTime`
- Animate with `animateFloatAsState`

### Migration Path
1. Create new Android project in Android Studio
2. Select "Empty Activity" with Compose
3. Configure Kotlin 2.0 with Compose Compiler plugin
4. Implement TimePicker for target time selection
5. Build custom circular progress with Canvas
6. Implement countdown logic with coroutines
7. Add control buttons (pause/stop/reset)

## Implementation Blueprint

### Prerequisites
- [ ] Install Android Studio (Electric Eel or newer)
- [ ] Ensure Android SDK 34 is installed
- [ ] Ensure Kotlin plugin is updated

### Step-by-Step Implementation

#### Step 1: Create New Android Project
```
1. Open Android Studio
2. File → New → New Project
3. Select "Empty Activity" (Compose variant)
4. Configure:
   - Name: CountdownHour
   - Package: com.countdownhour
   - Language: Kotlin
   - Minimum SDK: API 21
5. Click Finish
```
- **Expected outcome**: Base project structure with Compose configured

#### Step 2: Configure Gradle Dependencies
**File: `gradle/libs.versions.toml`**
```toml
[versions]
kotlin = "2.0.0"
compose-bom = "2024.02.00"
activity-compose = "1.8.2"
lifecycle = "2.7.0"
coroutines = "1.7.3"

[libraries]
compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "compose-bom" }
compose-ui = { group = "androidx.compose.ui", name = "ui" }
compose-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
compose-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
compose-material3 = { group = "androidx.compose.material3", name = "material3" }
activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activity-compose" }
lifecycle-runtime-compose = { group = "androidx.lifecycle", name = "lifecycle-runtime-compose", version.ref = "lifecycle" }
lifecycle-viewmodel-compose = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-compose", version.ref = "lifecycle" }
coroutines-android = { group = "org.jetbrains.kotlinx", name = "kotlinx-coroutines-android", version.ref = "coroutines" }

[plugins]
android-application = { id = "com.android.application", version = "8.2.2" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
compose-compiler = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }
```

**File: `app/build.gradle.kts`**
```kotlin
plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.compose.compiler)
}

android {
    namespace = "com.countdownhour"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.countdownhour"
        minSdk = 21
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = "17"
    }
    buildFeatures {
        compose = true
    }
}

dependencies {
    implementation(platform(libs.compose.bom))
    implementation(libs.compose.ui)
    implementation(libs.compose.ui.graphics)
    implementation(libs.compose.ui.tooling.preview)
    implementation(libs.compose.material3)
    implementation(libs.activity.compose)
    implementation(libs.lifecycle.runtime.compose)
    implementation(libs.lifecycle.viewmodel.compose)
    implementation(libs.coroutines.android)

    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")
}
```

- **Expected outcome**: Project configured with all required dependencies

#### Step 3: Create Timer State Model
**File: `app/src/main/java/com/countdownhour/data/TimerState.kt`**
```kotlin
package com.countdownhour.data

enum class TimerStatus {
    IDLE,      // Timer not started
    RUNNING,   // Timer counting down
    PAUSED,    // Timer paused
    FINISHED   // Timer completed
}

data class TimerState(
    val targetHour: Int = 0,
    val targetMinute: Int = 0,
    val remainingMillis: Long = 0L,
    val totalMillis: Long = 0L,
    val status: TimerStatus = TimerStatus.IDLE
) {
    val remainingHours: Int
        get() = (remainingMillis / 3600000).toInt()

    val remainingMinutes: Int
        get() = ((remainingMillis % 3600000) / 60000).toInt()

    val remainingSeconds: Int
        get() = ((remainingMillis % 60000) / 1000).toInt()

    val progress: Float
        get() = if (totalMillis > 0) remainingMillis.toFloat() / totalMillis else 0f
}
```

- **Expected outcome**: Data class representing timer state with computed properties

#### Step 4: Create Timer ViewModel
**File: `app/src/main/java/com/countdownhour/viewmodel/TimerViewModel.kt`**
```kotlin
package com.countdownhour.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.countdownhour.data.TimerState
import com.countdownhour.data.TimerStatus
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import java.util.Calendar

class TimerViewModel : ViewModel() {

    private val _timerState = MutableStateFlow(TimerState())
    val timerState: StateFlow<TimerState> = _timerState.asStateFlow()

    private var timerJob: Job? = null

    fun setTargetTime(hour: Int, minute: Int) {
        _timerState.value = _timerState.value.copy(
            targetHour = hour,
            targetMinute = minute
        )
    }

    fun start() {
        val state = _timerState.value
        val now = Calendar.getInstance()
        val target = Calendar.getInstance().apply {
            set(Calendar.HOUR_OF_DAY, state.targetHour)
            set(Calendar.MINUTE, state.targetMinute)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)
            // If target time is before now, set it for tomorrow
            if (before(now)) {
                add(Calendar.DAY_OF_MONTH, 1)
            }
        }

        val totalMillis = target.timeInMillis - now.timeInMillis

        _timerState.value = state.copy(
            totalMillis = totalMillis,
            remainingMillis = totalMillis,
            status = TimerStatus.RUNNING
        )

        startCountdown()
    }

    private fun startCountdown() {
        timerJob?.cancel()
        timerJob = viewModelScope.launch {
            while (_timerState.value.remainingMillis > 0 &&
                   _timerState.value.status == TimerStatus.RUNNING) {
                delay(1000L)
                _timerState.value = _timerState.value.copy(
                    remainingMillis = (_timerState.value.remainingMillis - 1000).coerceAtLeast(0)
                )
            }
            if (_timerState.value.remainingMillis <= 0) {
                _timerState.value = _timerState.value.copy(status = TimerStatus.FINISHED)
            }
        }
    }

    fun pause() {
        timerJob?.cancel()
        _timerState.value = _timerState.value.copy(status = TimerStatus.PAUSED)
    }

    fun resume() {
        _timerState.value = _timerState.value.copy(status = TimerStatus.RUNNING)
        startCountdown()
    }

    fun stop() {
        timerJob?.cancel()
        _timerState.value = TimerState()
    }

    fun reset() {
        timerJob?.cancel()
        val state = _timerState.value
        _timerState.value = state.copy(
            remainingMillis = state.totalMillis,
            status = TimerStatus.IDLE
        )
    }

    override fun onCleared() {
        super.onCleared()
        timerJob?.cancel()
    }
}
```

- **Expected outcome**: ViewModel managing timer logic with coroutines

#### Step 5: Create Circular Progress Composable
**File: `app/src/main/java/com/countdownhour/ui/components/CircularProgress.kt`**
```kotlin
package com.countdownhour.ui.components

import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.size
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp

@Composable
fun CircularProgress(
    progress: Float,
    modifier: Modifier = Modifier,
    size: Dp = 250.dp,
    strokeWidth: Dp = 12.dp,
    backgroundColor: Color = MaterialTheme.colorScheme.surfaceVariant,
    progressColor: Color = MaterialTheme.colorScheme.primary,
    content: @Composable () -> Unit = {}
) {
    val animatedProgress by animateFloatAsState(
        targetValue = progress,
        animationSpec = tween(durationMillis = 300),
        label = "progress"
    )

    Box(
        contentAlignment = Alignment.Center,
        modifier = modifier.size(size)
    ) {
        Canvas(modifier = Modifier.size(size)) {
            val strokeWidthPx = strokeWidth.toPx()
            val arcSize = Size(
                width = size.toPx() - strokeWidthPx,
                height = size.toPx() - strokeWidthPx
            )
            val topLeft = Offset(strokeWidthPx / 2, strokeWidthPx / 2)

            // Background circle
            drawArc(
                color = backgroundColor,
                startAngle = 0f,
                sweepAngle = 360f,
                useCenter = false,
                topLeft = topLeft,
                size = arcSize,
                style = Stroke(width = strokeWidthPx, cap = StrokeCap.Round)
            )

            // Progress arc (starts from 12 o'clock position)
            drawArc(
                color = progressColor,
                startAngle = -90f, // 12 o'clock position
                sweepAngle = animatedProgress * 360f,
                useCenter = false,
                topLeft = topLeft,
                size = arcSize,
                style = Stroke(width = strokeWidthPx, cap = StrokeCap.Round)
            )
        }

        content()
    }
}
```

- **Expected outcome**: Reusable circular progress indicator component

#### Step 6: Create Time Picker Dialog
**File: `app/src/main/java/com/countdownhour/ui/components/TimePickerDialog.kt`**
```kotlin
package com.countdownhour.ui.components

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TimePicker
import androidx.compose.material3.rememberTimePickerState
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import java.util.Calendar

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TimePickerDialog(
    onDismiss: () -> Unit,
    onConfirm: (hour: Int, minute: Int) -> Unit
) {
    val currentTime = Calendar.getInstance()
    val timePickerState = rememberTimePickerState(
        initialHour = currentTime.get(Calendar.HOUR_OF_DAY),
        initialMinute = currentTime.get(Calendar.MINUTE),
        is24Hour = true
    )

    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = {
            TextButton(
                onClick = {
                    onConfirm(timePickerState.hour, timePickerState.minute)
                }
            ) {
                Text("Confirm")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        },
        title = { Text("Select Target Time") },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                TimePicker(state = timePickerState)
            }
        }
    )
}
```

- **Expected outcome**: Dialog with Material 3 time picker

#### Step 7: Create Control Buttons Component
**File: `app/src/main/java/com/countdownhour/ui/components/ControlButtons.kt`**
```kotlin
package com.countdownhour.ui.components

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Pause
import androidx.compose.material.icons.filled.PlayArrow
import androidx.compose.material.icons.filled.Refresh
import androidx.compose.material.icons.filled.Stop
import androidx.compose.material3.FilledIconButton
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButtonDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.countdownhour.data.TimerStatus

@Composable
fun ControlButtons(
    status: TimerStatus,
    onStart: () -> Unit,
    onPause: () -> Unit,
    onResume: () -> Unit,
    onStop: () -> Unit,
    onReset: () -> Unit,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier,
        horizontalArrangement = Arrangement.Center,
        verticalAlignment = Alignment.CenterVertically
    ) {
        when (status) {
            TimerStatus.IDLE -> {
                // Show Start button
                FilledIconButton(
                    onClick = onStart,
                    modifier = Modifier.size(64.dp),
                    colors = IconButtonDefaults.filledIconButtonColors(
                        containerColor = MaterialTheme.colorScheme.primary
                    )
                ) {
                    Icon(
                        imageVector = Icons.Default.PlayArrow,
                        contentDescription = "Start",
                        modifier = Modifier.size(32.dp)
                    )
                }
            }

            TimerStatus.RUNNING -> {
                // Show Pause and Stop buttons
                FilledIconButton(
                    onClick = onPause,
                    modifier = Modifier.size(56.dp),
                    colors = IconButtonDefaults.filledIconButtonColors(
                        containerColor = MaterialTheme.colorScheme.secondary
                    )
                ) {
                    Icon(
                        imageVector = Icons.Default.Pause,
                        contentDescription = "Pause",
                        modifier = Modifier.size(28.dp)
                    )
                }

                Spacer(modifier = Modifier.width(24.dp))

                FilledIconButton(
                    onClick = onStop,
                    modifier = Modifier.size(56.dp),
                    colors = IconButtonDefaults.filledIconButtonColors(
                        containerColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Icon(
                        imageVector = Icons.Default.Stop,
                        contentDescription = "Stop",
                        modifier = Modifier.size(28.dp)
                    )
                }
            }

            TimerStatus.PAUSED -> {
                // Show Resume, Reset, and Stop buttons
                FilledIconButton(
                    onClick = onResume,
                    modifier = Modifier.size(56.dp),
                    colors = IconButtonDefaults.filledIconButtonColors(
                        containerColor = MaterialTheme.colorScheme.primary
                    )
                ) {
                    Icon(
                        imageVector = Icons.Default.PlayArrow,
                        contentDescription = "Resume",
                        modifier = Modifier.size(28.dp)
                    )
                }

                Spacer(modifier = Modifier.width(16.dp))

                FilledIconButton(
                    onClick = onReset,
                    modifier = Modifier.size(56.dp),
                    colors = IconButtonDefaults.filledIconButtonColors(
                        containerColor = MaterialTheme.colorScheme.tertiary
                    )
                ) {
                    Icon(
                        imageVector = Icons.Default.Refresh,
                        contentDescription = "Reset",
                        modifier = Modifier.size(28.dp)
                    )
                }

                Spacer(modifier = Modifier.width(16.dp))

                FilledIconButton(
                    onClick = onStop,
                    modifier = Modifier.size(56.dp),
                    colors = IconButtonDefaults.filledIconButtonColors(
                        containerColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Icon(
                        imageVector = Icons.Default.Stop,
                        contentDescription = "Stop",
                        modifier = Modifier.size(28.dp)
                    )
                }
            }

            TimerStatus.FINISHED -> {
                // Show Reset button
                FilledIconButton(
                    onClick = onStop,
                    modifier = Modifier.size(64.dp),
                    colors = IconButtonDefaults.filledIconButtonColors(
                        containerColor = MaterialTheme.colorScheme.primary
                    )
                ) {
                    Icon(
                        imageVector = Icons.Default.Refresh,
                        contentDescription = "New Timer",
                        modifier = Modifier.size(32.dp)
                    )
                }
            }
        }
    }
}
```

- **Expected outcome**: Context-aware control buttons based on timer status

#### Step 8: Create Main Timer Screen
**File: `app/src/main/java/com/countdownhour/ui/screens/TimerScreen.kt`**
```kotlin
package com.countdownhour.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.countdownhour.data.TimerStatus
import com.countdownhour.ui.components.CircularProgress
import com.countdownhour.ui.components.ControlButtons
import com.countdownhour.ui.components.TimePickerDialog
import com.countdownhour.viewmodel.TimerViewModel

@Composable
fun TimerScreen(
    viewModel: TimerViewModel = viewModel()
) {
    val timerState by viewModel.timerState.collectAsState()
    var showTimePicker by remember { mutableStateOf(false) }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(24.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        // Target time display
        if (timerState.status != TimerStatus.IDLE) {
            Text(
                text = "Target: ${String.format("%02d:%02d", timerState.targetHour, timerState.targetMinute)}",
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            Spacer(modifier = Modifier.height(24.dp))
        }

        // Circular progress with countdown
        CircularProgress(
            progress = timerState.progress,
            progressColor = when (timerState.status) {
                TimerStatus.RUNNING -> MaterialTheme.colorScheme.primary
                TimerStatus.PAUSED -> MaterialTheme.colorScheme.secondary
                TimerStatus.FINISHED -> MaterialTheme.colorScheme.tertiary
                else -> MaterialTheme.colorScheme.primary
            }
        ) {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                if (timerState.status == TimerStatus.IDLE) {
                    Text(
                        text = "Set Time",
                        style = MaterialTheme.typography.headlineSmall,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                } else {
                    // Hours
                    Text(
                        text = String.format("%02d", timerState.remainingHours),
                        fontSize = 48.sp,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                    Text(
                        text = "hours",
                        style = MaterialTheme.typography.labelSmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )

                    Spacer(modifier = Modifier.height(4.dp))

                    // Minutes and Seconds
                    Text(
                        text = String.format(
                            "%02d:%02d",
                            timerState.remainingMinutes,
                            timerState.remainingSeconds
                        ),
                        fontSize = 32.sp,
                        fontWeight = FontWeight.Medium,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                    Text(
                        text = "min : sec",
                        style = MaterialTheme.typography.labelSmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
        }

        Spacer(modifier = Modifier.height(48.dp))

        // Time picker button (only when idle)
        if (timerState.status == TimerStatus.IDLE) {
            Button(onClick = { showTimePicker = true }) {
                Text("Select Target Time")
            }
            Spacer(modifier = Modifier.height(24.dp))
        }

        // Control buttons
        ControlButtons(
            status = timerState.status,
            onStart = { viewModel.start() },
            onPause = { viewModel.pause() },
            onResume = { viewModel.resume() },
            onStop = { viewModel.stop() },
            onReset = { viewModel.reset() }
        )

        // Status text
        if (timerState.status == TimerStatus.FINISHED) {
            Spacer(modifier = Modifier.height(24.dp))
            Text(
                text = "Time's Up!",
                style = MaterialTheme.typography.headlineMedium,
                color = MaterialTheme.colorScheme.primary,
                fontWeight = FontWeight.Bold
            )
        }
    }

    // Time picker dialog
    if (showTimePicker) {
        TimePickerDialog(
            onDismiss = { showTimePicker = false },
            onConfirm = { hour, minute ->
                viewModel.setTargetTime(hour, minute)
                showTimePicker = false
            }
        )
    }
}
```

- **Expected outcome**: Main screen composable with all UI elements

#### Step 9: Create App Theme
**File: `app/src/main/java/com/countdownhour/ui/theme/Theme.kt`**
```kotlin
package com.countdownhour.ui.theme

import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext

private val DarkColorScheme = darkColorScheme(
    primary = Color(0xFF90CAF9),
    secondary = Color(0xFFFFCC80),
    tertiary = Color(0xFFA5D6A7),
    error = Color(0xFFEF9A9A),
    background = Color(0xFF121212),
    surface = Color(0xFF1E1E1E),
    onPrimary = Color.Black,
    onSecondary = Color.Black,
    onTertiary = Color.Black,
    onBackground = Color.White,
    onSurface = Color.White
)

private val LightColorScheme = lightColorScheme(
    primary = Color(0xFF1976D2),
    secondary = Color(0xFFFF9800),
    tertiary = Color(0xFF4CAF50),
    error = Color(0xFFF44336),
    background = Color(0xFFFAFAFA),
    surface = Color.White,
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color.Black,
    onSurface = Color.Black
)

@Composable
fun CountdownHourTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }
        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        content = content
    )
}
```

- **Expected outcome**: Material 3 theme with dynamic colors support

#### Step 10: Update MainActivity
**File: `app/src/main/java/com/countdownhour/MainActivity.kt`**
```kotlin
package com.countdownhour

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Surface
import androidx.compose.ui.Modifier
import com.countdownhour.ui.screens.TimerScreen
import com.countdownhour.ui.theme.CountdownHourTheme

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            CountdownHourTheme {
                Surface(modifier = Modifier.fillMaxSize()) {
                    TimerScreen()
                }
            }
        }
    }
}
```

- **Expected outcome**: Entry point activity with Compose setup

### Validation Checklist
- [ ] Project builds without errors: `./gradlew build`
- [ ] App launches on emulator/device
- [ ] Time picker dialog opens and accepts selection
- [ ] Countdown starts from current time to target time
- [ ] Circular progress reflects time remaining
- [ ] Pause button stops countdown and preserves state
- [ ] Resume button continues countdown from paused state
- [ ] Stop button resets to idle state
- [ ] Reset button restarts countdown from beginning
- [ ] Timer displays "Time's Up!" when finished
- [ ] App works in portrait and landscape orientations
- [ ] Dark mode theme is properly applied

## Risk Assessment

### High Risk
- **TimePicker API is experimental** → Mitigation: Use `@OptIn(ExperimentalMaterial3Api::class)` annotation, monitor for API changes in future releases

### Medium Risk
- **Timer accuracy on background** → Mitigation: For MVP, accept that timer may drift when app is backgrounded. Future enhancement: use `WorkManager` or `AlarmManager` for background timing
- **Configuration changes (rotation)** → Mitigation: ViewModel handles state persistence across configuration changes

### Low Risk
- **Gradle sync issues** → Mitigation: Ensure all version catalogs are correctly configured
- **Icon imports** → Mitigation: Add `implementation("androidx.compose.material:material-icons-extended")` if Icons.Default.* are not found

### Rollback Plan
1. If project creation fails, delete folder and recreate with different settings
2. If dependencies conflict, check Compose BOM compatibility matrix
3. If TimePicker crashes, implement custom wheel picker or number inputs
4. Keep version control (git init) to track changes and revert if needed

## Quality Assessment

### Context Completeness Score: 9/10
- Project analysis: 10/10 (Empty folder, clear requirements)
- Documentation coverage: 9/10 (Official Android docs + community tutorials)
- Implementation detail: 9/10 (Full code snippets for all components)

### Confidence Score: 9/10
**Rationale:**
- Jetpack Compose setup is well-documented and straightforward
- All required components (TimePicker, Canvas, ViewModel) have official support
- Coroutines for timer logic is a well-established pattern
- Minor risk with experimental TimePicker API, but has stable behavior
- Only deduction: Timer accuracy when app is backgrounded is a known Android limitation

### Missing Information
- User's preferred color scheme (using Material dynamic colors as default)
- Sound/vibration on timer completion (not implemented in MVP)
- Keep screen on during countdown (can be added with `FLAG_KEEP_SCREEN_ON`)

## Next Steps
1. Create the Android Studio project following Step 1
2. Configure Gradle dependencies (Step 2)
3. Implement all code files in order (Steps 3-10)
4. Run validation checklist
5. Consider future enhancements:
   - Notification when timer completes
   - Multiple timers support
   - Timer history
   - Widget for home screen

## File Structure Overview
```
app/
├── build.gradle.kts
├── src/main/
│   ├── java/com/countdownhour/
│   │   ├── MainActivity.kt
│   │   ├── data/
│   │   │   └── TimerState.kt
│   │   ├── viewmodel/
│   │   │   └── TimerViewModel.kt
│   │   └── ui/
│   │       ├── components/
│   │       │   ├── CircularProgress.kt
│   │       │   ├── ControlButtons.kt
│   │       │   └── TimePickerDialog.kt
│   │       ├── screens/
│   │       │   └── TimerScreen.kt
│   │       └── theme/
│   │           └── Theme.kt
│   ├── res/
│   │   └── values/
│   │       ├── strings.xml
│   │       └── themes.xml
│   └── AndroidManifest.xml
gradle/
└── libs.versions.toml
```
